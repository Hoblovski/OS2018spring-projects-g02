	.text
	.section .mdebug.abiO32
	.previous


	.globl	reply_message
	.p2align	2
	.type	reply_message,@function
	.ent	reply_message                    # @taskexit
reply_message:
	.set	noreorder
	.set	nomacro

  # has two args, in a0 and a1, store them onto stack
  addiu $sp, $sp, -8
  sto $a1, 4($sp)
  sto $a0, 0($sp)
  addiu $a0, $zr, 2

	lui	$a1, %hi(k_reply_message)
	ori	$a1, $a1, %lo(k_reply_message)
	lui	$t1, %hi(do_kernel_method)
	ori	$t1, $t1, %lo(do_kernel_method)
  jr $t1

	.set	macro
	.set	reorder
	.end	reply_message
$reply_message_end:
	.size	reply_message, ($reply_message_end)-reply_message


	.globl	receive_message
	.p2align	2
	.type	receive_message,@function
	.ent	receive_message                    # @taskexit
receive_message:
	.set	noreorder
	.set	nomacro

  # has one args, in a0, store onto stack
  addiu $sp, $sp, -4
  sto $a0, 0($sp)
  addiu $a0, $zr, 1

	lui	$a1, %hi(k_receive_message)
	ori	$a1, $a1, %lo(k_receive_message)
	lui	$t1, %hi(do_kernel_method)
	ori	$t1, $t1, %lo(do_kernel_method)
  jr $t1

	.set	macro
	.set	reorder
	.end	receive_message
$receive_message_end:
	.size	receive_message, ($receive_message_end)-receive_message


	.globl	send_message
	.p2align	2
	.type	send_message,@function
	.ent	send_message                    # @taskexit
send_message:
	.set	noreorder
	.set	nomacro

  # has three args, in a0 and a1, the third arg is in 8($sp)
  # (from code analysis)
  # store them onto stack
  loa $t0, 8($sp)
  addiu $sp, $sp, -12
  sto $a0, 0($sp)
  sto $a1, 4($sp)
  sto $t0, 8($sp)
  addiu $a0, $zr, 3

	lui	$a1, %hi(k_send_message)
	ori	$a1, $a1, %lo(k_send_message)
	lui	$t1, %hi(do_kernel_method)
	ori	$t1, $t1, %lo(do_kernel_method)
  jr $t1

	.set	macro
	.set	reorder
	.end	send_message
$send_message_end:
	.size	send_message, ($send_message_end)-send_message


	.globl	block_on_event
	.p2align	2
	.type	block_on_event,@function
	.ent	block_on_event                    # @taskexit
block_on_event:
	.set	noreorder
	.set	nomacro

  # has one args, in a0, store onto stack
  addiu $sp, $sp, -4
  sto $a0, 0($sp)
  addiu $a0, $zr, 1

	lui	$a1, %hi(k_block_on_event)
	ori	$a1, $a1, %lo(k_block_on_event)
	lui	$t1, %hi(do_kernel_method)
	ori	$t1, $t1, %lo(do_kernel_method)
  jr $t1

	.set	macro
	.set	reorder
	.end	block_on_event
$block_on_event_end:
	.size	block_on_event, ($block_on_event_end)-block_on_event


	.globl	task_exit
	.p2align	2
	.type	task_exit,@function
	.ent	task_exit                    # @taskexit
task_exit:
	.set	noreorder
	.set	nomacro

  # no args
  add $a0, $zr, $zr

	lui	$a1, %hi(k_task_exit)
	ori	$a1, $a1, %lo(k_task_exit)
	lui	$t1, %hi(do_kernel_method)
	ori	$t1, $t1, %lo(do_kernel_method)
  jr $t1

	.set	macro
	.set	reorder
	.end	task_exit
$task_exit_end:
	.size	task_exit, ($task_exit_end)-task_exit


	.globl	kernel_init
	.p2align	2
	.type	kernel_init,@function
	.ent	kernel_init                    # @taskexit
kernel_init:
	.set	noreorder
	.set	nomacro

  # no args
  add $a0, $zr, $zr

	lui	$a1, %hi(k_kernel_init)
	ori	$a1, $a1, %lo(k_kernel_init)
	lui	$t1, %hi(do_kernel_method)
	ori	$t1, $t1, %lo(do_kernel_method)
  jr $t1

	.set	macro
	.set	reorder
	.end	kernel_init
$kernel_init_end:
	.size	kernel_init, ($kernel_init_end)-kernel_init


	.globl	kernel_exit
	.p2align	2
	.type	kernel_exit,@function
	.ent	kernel_exit                    # @taskexit
kernel_exit:
	.set	noreorder
	.set	nomacro

  # no args
  add $a0, $zr, $zr

	lui	$a1, %hi(k_kernel_exit)
	ori	$a1, $a1, %lo(k_kernel_exit)
	lui	$t1, %hi(do_kernel_method)
	ori	$t1, $t1, %lo(do_kernel_method)
  jr $t1

	.set	macro
	.set	reorder
	.end	kernel_exit
$kernel_exit_end:
	.size	kernel_exit, ($kernel_exit_end)-kernel_exit


	.globl	release_processor
	.p2align	2
	.type	release_processor,@function
	.ent	release_processor                    # @taskexit
release_processor:
	.set	noreorder
	.set	nomacro

  # no args
  add $a0, $zr, $zr

	lui	$a1, %hi(k_release_processor)
	ori	$a1, $a1, %lo(k_release_processor)
	lui	$t1, %hi(do_kernel_method)
	ori	$t1, $t1, %lo(do_kernel_method)
  jr $t1

	.set	macro
	.set	reorder
	.end	release_processor
$release_processor_end:
	.size	release_processor, ($release_processor_end)-release_processor


	.globl	or_into_flags_register
	.p2align	2
	.type	or_into_flags_register,@function
	.ent	or_into_flags_register                    # @taskexit
or_into_flags_register:
	.set	noreorder
	.set	nomacro

  or $fr, $fr, $a0
  ret $lr

	.set	macro
	.set	reorder
	.end	or_into_flags_register
$or_into_flags_register_end:
	.size	or_into_flags_register, ($or_into_flags_register_end)-or_into_flags_register


	.globl	deassert_bits_in_flags_register
	.p2align	2
	.type	deassert_bits_in_flags_register,@function
	.ent	deassert_bits_in_flags_register                    # @taskexit
deassert_bits_in_flags_register:
	.set	noreorder
	.set	nomacro

  addiu $t0, $zr, -1
  xor $t0, $t0, $a0
  and $fr, $fr, $t0
	ret $lr

	.set	macro
	.set	reorder
	.end	deassert_bits_in_flags_register
$deassert_bits_in_flags_register_end:
	.size	deassert_bits_in_flags_register, ($deassert_bits_in_flags_register_end)-deassert_bits_in_flags_register


	.globl	read_flags_register
	.p2align	2
	.type	read_flags_register,@function
	.ent	read_flags_register                    # @taskexit
read_flags_register:
	.set	noreorder
	.set	nomacro

  add $v0, $fr, $zr
  jr $t1

	.set	macro
	.set	reorder
	.end	read_flags_register
$read_flags_register_end:
	.size	read_flags_register, ($read_flags_register_end)-read_flags_register


	.globl	init_task_stack
	.p2align	2
	.type	init_task_stack,@function
	.ent	init_task_stack                    # @taskexit
init_task_stack:
	.set	noreorder
	.set	nomacro

  # init_task_stack( task_sp_addr, task_pc )
  #   task_sp_addr: intptr_t*,  -> new task's SP
  #   task_pc: from where should this task start execution

  # task stack initial content:
  #
  #   top   -8    0  (scheduling come from kernel call)
  #
  #         -4    FP (should be 0)
  #
  #          0    PC (where does the task start)

  loa $t0, 0($a0)
  sto $a1, 0($t0)   # push PC
  sto $zr, -4($t0)  # push FP [=0]
  sto $zr, -8($t0)  # push SCH_KERN [=0]
  addiu $t0, $t0, -8  # modify sp
  sto $t0, 0($a0)
  ret $lr

	.set	macro
	.set	reorder
	.end	init_task_stack
$init_task_stack_end:
	.size	init_task_stack, ($init_task_stack_end)-init_task_stack


# Private part
do_kernel_method:
# now in
#         a1: delegate function
#         a0: num of args to pass to delegate function
#         0(sp): first arg    ## args pushed from right to left
#         -4(sp): second arg
#         ...
#
#         when scheduled out:
#           在 current 的栈上而不是 kernel 栈上
#           push return_PC
#           push IMM
#                     if scheduling happen because of kernel method
#                       IMM = 4
#                     else
#                       IMM = 0
  addiu $t0, $zr, -3  # t0 = ~(1<<1)
  and $fr, $fr, $t0   # 关中断

                      # 保存信息
  addiu $sp, $sp, -8
	lui	$t0, %hi(method_exit_premption_enabled)
	ori	$t0, $t0, %lo(method_exit_premption_enabled)
  sto $t0, 4($sp)
  sto $zr, 0($sp)

                      # 换栈. 旧的 SP 存到全局变量 g_current_sp 里
                      #       切换到内核栈 g_kernel_sp
  add $t9, $sp, $zr         # 旧栈保存在 t9 中
  lui	$t0, %hi(g_current_sp)
  ori	$t0, $t0, %lo(g_current_sp)
  sto $sp, 0($t0)     # 确实需要的话这里可以压缩指令大小
  lui	$t0, %hi(g_kernel_sp)
  ori	$t0, $t0, %lo(g_kernel_sp)
  loa $sp, 0($t0)

  # 设置给 after kernel return 的信息
  lui	$t0, %hi(after_kernel_method_return)
  ori	$t0, $t0, %lo(after_kernel_method_return)
  addiu $sp, $sp, -8
  sto $t0, 4($sp)     # 压入 retaddr
  sto $zr, 0($sp)     # 压入 0, 表示是 kernel method

  add $t0, $a0, $zr   # t0: num of args
  add $t1, $a1, $zr   # t1: delegate function

#   according to t0
#     load args into a0, a1 and on stack
#     arg 0 : -8(t9)
#     arg 1 : -12(t9)
# TODO: support more than 3 args
# 给具体的 k_kernelmethod 传参
  addiu $a0, $zr, 3
  blt $t0, $a0, $lbl3
  loa $a0, -16($t9)
  sto $a0, 8($sp)
$lbl3:
  loa $a0, -8($t9)
  loa $a1, -12($t9)
  jr $t1



after_kernel_method_return:
                      # 换栈. 旧的 SP 存到全局变量 g_current_sp 里
                      #       切换到内核栈 g_kernel_sp
  lui	$t0, %hi(g_current_sp)
  ori	$t0, $t0, %lo(g_current_sp)
  loa $sp, 0($t0)     # 确实需要的话这里可以压缩指令大小

  loa $t0, 0($sp)
  addiu $sp, $sp, 4
  beq $t0, $zr, exit_kernel_method
  beq $zr, $zr, irq_exit


exit_kernel_method:
  or $fr, $fr, $wr # eret

method_exit_premption_enabled:
  ret $lr

	.globl	irq_handler
	.p2align	2
	.type	irq_handler,@function
	.ent	irq_handler                    # @taskexit
irq_handler:
	.set	noreorder
	.set	nomacro
  addiu $sp, $sp, -36

  sto $v0, 0($sp)
  sto $v1, 4($sp)
  sto $a0, 8($sp)
  sto $a1, 12($sp)
  sto $s0, 16($sp)
  sto $s1, 20($sp)
  sto $t0, 24($sp)
  sto $t1, 28($sp)
  sto $t9, 32($sp)

  addiu $sp, $sp, -8
  lui	$t0, %hi(after_kernel_irq_return)
  ori	$t0, $t0, %lo(after_kernel_irq_return)
  sto $t0, 4($sp)
  sto $wr, 0($sp)
    # push retaddr; push 4

irq_interrupt_chosen:
  lui	$t0, %hi(g_current_sp)
  ori	$t0, $t0, %lo(g_current_sp)
  sto $sp, 0($t0)     # 确实需要的话这里可以压缩指令大小
  lui	$t0, %hi(g_kernel_sp)
  ori	$t0, $t0, %lo(g_kernel_sp)
  loa $sp, 0($t0)

  lui	$t0, %hi(k_irq_handler)
  ori	$t0, $t0, %lo(k_irq_handler)
  jr $t0

after_kernel_irq_return:
  lui	$t0, %hi(g_current_sp)
  ori	$t0, $t0, %lo(g_current_sp)
  loa $sp, 0($t0)

  loa $t0, 0($sp)
  addiu $sp, $sp, 4

  beq $t0, $zr, exit_kernel_method
  # t0 应该是 4, 只有 0 和 4 的标志
irq_exit:
  loa $v0, 4($sp)
  loa $v1, 8($sp)
  loa $a0, 12($sp)
  loa $a1, 16($sp)
  loa $s0, 20($sp)
  loa $s1, 24($sp)
  loa $t0, 28($sp)
  loa $t1, 32($sp)
  loa $t9, 36($sp)

  addiu $sp, $sp, 36
  loa $t0, $

  or $fr, $fr, $wr
	.set	macro
	.set	reorder
	.end	irq_handler
$irq_handler_end:
	.size	irq_handler, ($irq_handler_end)-irq_handler
