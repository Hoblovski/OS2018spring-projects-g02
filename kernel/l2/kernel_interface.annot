OFFSET RELOCATABLE
FUNCTION kernel_interface_start kernel_interface_end;
IMPLEMENTS INTERNAL kernel_interface_start;
IMPLEMENTS INTERNAL kernel_interface_end;
REQUIRES EXTERNAL globalvar_g_current_sp;
REQUIRES EXTERNAL globalvar_g_kernel_sp;
IMPLEMENTS EXTERNAL task_exit;
IMPLEMENTS EXTERNAL irq_handler;
IMPLEMENTS EXTERNAL kernel_init;
IMPLEMENTS EXTERNAL kernel_exit;
IMPLEMENTS EXTERNAL release_processor;
IMPLEMENTS EXTERNAL block_on_event;
IMPLEMENTS EXTERNAL send_message;
IMPLEMENTS EXTERNAL receive_message;
IMPLEMENTS EXTERNAL reply_message;
REQUIRES EXTERNAL k_task_exit;
REQUIRES EXTERNAL k_irq_handler;
REQUIRES EXTERNAL k_kernel_init;
REQUIRES EXTERNAL k_kernel_exit;
REQUIRES EXTERNAL k_release_processor;
REQUIRES EXTERNAL k_block_on_event;
REQUIRES EXTERNAL k_send_message;
REQUIRES EXTERNAL k_receive_message;
REQUIRES EXTERNAL k_reply_message;
IMPLEMENTS, REQUIRES INTERNAL do_kernel_method;
IMPLEMENTS, REQUIRES INTERNAL exit_kernel_method;
IMPLEMENTS, REQUIRES INTERNAL irq_exit;
IMPLEMENTS, REQUIRES INTERNAL irq_interrupt_chosen;
IMPLEMENTS, REQUIRES INTERNAL method_exit_premption_enabled;
IMPLEMENTS, REQUIRES INTERNAL after_kernel_method_return;
IMPLEMENTS, REQUIRES INTERNAL after_kernel_irq_return;
IMPLEMENTS EXTERNAL init_task_stack;
IMPLEMENTS EXTERNAL or_into_flags_register;
IMPLEMENTS EXTERNAL deassert_bits_in_flags_register;
IMPLEMENTS EXTERNAL read_flags_register;

kernel_interface_start:

reply_message:
  r5 = k_reply_message
  goto do_kernel_method

; similar for
receive_message:
send_message:
block_on_event:
task_exit:
kernel_init:
kernel_exit:
release_processor:
  ...

or_into_flags_register:
  FR = FR | a0
  ret

deassert_bits_in_flags_register:
  FR = FR & ~a0
  ret

init_task_stack:
                   ; a0->SP, a1=PC
  loa r3 a0;       Get the actual stack pointer variable value.
  sto r3 a1;       Store Function address
  sub r3 r3 WR;    Push
  sto r3 ZR;       Store zero for frame pointer.
  sub r3 r3 WR;    Push
  sto r3 ZR;       Store zero to signify scheduling as if from kernel call
  sto a0 r3;       We updated the stack of this task, save it
  ret

read_flags_register:
  v0 = FR
  ret


do_kernel_method:
  关中断

	在 current 栈上
    push 返回地址: method_exit_premption_enabled
    push 标志: 0
      表示这个进入内核态是因为调用了内核函数

  切换到内核栈
    g_current_sp = SP
    SP = g_kernel_sp

  在 kernel 栈上
    push 返回地址: after_kernel_method_return
    push 标志: 0

  复制参数
      r6 = FP - SP    ; 参数有多少字节
      r7 = r6
      goto lbl2
    lbl1:
      sub FP FP WR;    Next word
      sub SP SP WR;    Next word
      loa r2 FP;       Copy the value
      sto SP r2;       Store the value
      sub r6 r6 WR;    Decrement for count of arguments copied
      beq r6 ZR 1;
    lbl2:
      goto lbl1

  跳转到具体的内核函数
    add PC ZR r5;    Branch to our kernel method.

after_kernel_method_return:
  切换到应用栈
    SP = globalvar_g_current_sp

  检查应用栈栈顶标志
    if pop == 0
      goto exit_kernel_method
    else # 应该等于4
      goto irq_exit

exit_kernel_method:
  eret

method_exit_premption_enabled:
  ret

irq_handler:
  保存 GPR
    push r1
    push r2
    ...
    push r9
    push FP

  保存标志
    push imm:4

  切换到系统栈
    g_current_sp = SP
    SP = g_kernel_sp

  压入返回地址和标志
    r3 = &after_kernel_irq_return
    push r3
    push imm:0

  跳转到具体的系统函数
    goto k_irq_handler

after_kernel_irq_return:
  切换到应用栈
    r1 = &globalvar_g_current_sp
    SP = [r1]

  检查栈顶标志
    if pop == 0
      goto exit_kernel_method
    else # 应该等于4
      goto irq_exit

irq_exit:
  从栈上恢复 GPR
  eret

kernel_interface_end:
